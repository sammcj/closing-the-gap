---
// src/components/Chart.astro
import { CONFIG } from "../config";

export interface Props {
  id: string;
  title: string;
  data: any;
  isCombined?: boolean;
}

const { id, title, data, isCombined = false } = Astro.props;
---

<div class="chart-container">
  <div
    id={id}
    class="chart"
    style={`width: 100%; height: ${CONFIG.chartHeight}px;`}
    data-title={title}
    data-chart-data={JSON.stringify(data)}
    data-is-combined={isCombined}
  >
    <p>Loading chart...</p>
  </div>
  <div class="collapsible-table" data-chart-id={id}>
    <button class="toggle-table">Show Data</button>
    <div class="table-container hidden">
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Model Name</th>
            <th>Score</th>
          </tr>
        </thead>
        <tbody>
          {
            data.map((item) => (
              <tr>
                <td>{item.date}</td>
                <td>{item.name}</td>
                <td>{item.score.toFixed(2)}%</td>
              </tr>
            ))
          }
        </tbody>
      </table>
    </div>
  </div>
</div>

<style>
  .chart-container {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    overflow: hidden;
  }
  .chart-container:hover {
    box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
  }
  .collapsible-table {
    padding: 1rem;
  }
  .toggle-table {
    width: 100%;
    padding: 0.5rem;
    background-color: #f0f0f0;
    border: none;
    text-align: left;
    cursor: pointer;
  }
  .table-container {
    overflow-x: auto;
  }
  table {
    width: 100%;
    border-collapse: collapse;
  }
  th,
  td {
    padding: 0.5rem;
    text-align: left;
    border-bottom: 1px solid #e0e0e0;
  }
  th {
    background-color: #f5f5f5;
    font-weight: bold;
  }
  .hidden {
    display: none;
  }
</style>

<script>
  import * as echarts from "echarts/core";
  import { ScatterChart, LineChart } from "echarts/charts";
  import {
    TitleComponent,
    TooltipComponent,
    GridComponent,
    DatasetComponent,
    TransformComponent,
    LegendComponent,
    ToolboxComponent,
    DataZoomComponent,
  } from "echarts/components";
  import { LabelLayout, UniversalTransition } from "echarts/features";
  import { CanvasRenderer } from "echarts/renderers";
  import { CONFIG } from "../config";
  import dayjs from "dayjs";

  echarts.use([
    TitleComponent,
    TooltipComponent,
    GridComponent,
    DatasetComponent,
    TransformComponent,
    LegendComponent,
    ToolboxComponent,
    DataZoomComponent,
    ScatterChart,
    LineChart,
    LabelLayout,
    UniversalTransition,
    CanvasRenderer,
  ]);

  function calculateTrendAndPrediction(data, isOpen) {
    if (!data || data.length === 0) {
      console.warn("Empty or invalid data passed to calculateTrendAndPrediction");
      return {
        trendData: [],
        predictionData: [],
        color: isOpen ? CONFIG.openColor : CONFIG.closedColor,
        predictionColor: isOpen ? CONFIG.predictiveOpenColor : CONFIG.predictiveClosedColor,
      };
    }

    const sortedData = data.sort((a, b) => dayjs(a.date).valueOf() - dayjs(b.date).valueOf());

    // If there's only one data point, create a horizontal trend line and prediction
    if (sortedData.length === 1) {
      const point = sortedData[0];
      const date = dayjs(point.date).valueOf();
      const futureDate = dayjs(point.date).add(CONFIG.predictionMonths, "month").valueOf();
      return {
        trendData: [
          [date, point.score],
          [date + 86400000, point.score],
        ], // Add 24 hours for visibility
        predictionData: [
          [date, point.score],
          [futureDate, point.score],
        ], // Horizontal prediction
        color: isOpen ? CONFIG.openColor : CONFIG.closedColor,
        predictionColor: isOpen ? CONFIG.predictiveOpenColor : CONFIG.predictiveClosedColor,
      };
    }

    // Original trend calculation for multiple data points
    const trendData = [];
    let maxScore = -Infinity;

    sortedData.forEach((point) => {
      if (point.score > maxScore) {
        maxScore = point.score;
        trendData.push([dayjs(point.date).valueOf(), maxScore]);
      }
    });

    if (trendData.length === 0) {
      console.warn("No trend data could be calculated");
      return {
        trendData: [],
        predictionData: [],
        color: isOpen ? CONFIG.openColor : CONFIG.closedColor,
        predictionColor: isOpen ? CONFIG.predictiveOpenColor : CONFIG.predictiveClosedColor,
      };
    }

    // Calculate the rate of improvement
    const cutoffDate = dayjs(trendData[trendData.length - 1][0]).subtract(
      CONFIG.improvementCalculationMonths,
      "month"
    );
    const recentData = trendData.filter((point) => dayjs(point[0]).isAfter(cutoffDate));

    if (recentData.length < 2) {
      // Not enough data for prediction, return horizontal prediction
      const lastPoint = trendData[trendData.length - 1];
      const futureDate = dayjs(lastPoint[0]).add(CONFIG.predictionMonths, "month").valueOf();
      return {
        trendData,
        predictionData: [
          [lastPoint[0], lastPoint[1]],
          [futureDate, lastPoint[1]],
        ],
        color: isOpen ? CONFIG.openColor : CONFIG.closedColor,
        predictionColor: isOpen ? CONFIG.predictiveOpenColor : CONFIG.predictiveClosedColor,
      };
    }

    const firstRecentDate = dayjs(recentData[0][0]);
    const lastRecentDate = dayjs(recentData[recentData.length - 1][0]);
    const monthsDiff = lastRecentDate.diff(firstRecentDate, "month", true);
    const scoreImprovement = recentData[recentData.length - 1][1] - recentData[0][1];
    const monthlyImprovement = scoreImprovement / monthsDiff;

    // Generate prediction data
    const predictionData = [];
    let currentDate = lastRecentDate;
    let currentScore = recentData[recentData.length - 1][1];

    for (let i = 0; i <= CONFIG.predictionMonths; i++) {
      predictionData.push([currentDate.valueOf(), currentScore]);
      currentDate = currentDate.add(1, "month");
      currentScore += monthlyImprovement;
    }

    return {
      trendData,
      predictionData,
      color: isOpen ? CONFIG.openColor : CONFIG.closedColor,
      predictionColor: isOpen ? CONFIG.predictiveOpenColor : CONFIG.predictiveClosedColor,
    };
  }

  function renderChart(element) {
    const id = element.id;
    const title = element.getAttribute("data-title");
    const isCombined = element.getAttribute("data-is-combined") === "true";
    let data;
    try {
      data = JSON.parse(element.getAttribute("data-chart-data"));
    } catch (error) {
      console.error(`Failed to parse data for chart ${id}:`, error);
      element.innerHTML = `<p>Error: Failed to load chart data</p>`;
      return;
    }

    if (!data || data.length === 0) {
      console.warn(`No data available for chart ${id}`);
      element.innerHTML = `<p>No data available for this chart</p>`;
      return;
    }

    const chart = echarts.init(element);

    const openData = data.filter((d) => d.openClosed === "Open");
    const closedData = data.filter((d) => d.openClosed === "Closed");

    const openTrend = calculateTrendAndPrediction(openData, true);
    const closedTrend = calculateTrendAndPrediction(closedData, false);

    const option = {
      title: {
        text: title,
        left: "center",
        textStyle: {
          fontSize: 20,
          fontWeight: "bold",
        },
      },
      tooltip: {
        trigger: "item",
        formatter: function (params) {
          if (params.seriesName === "Open" || params.seriesName === "Closed") {
            const date = dayjs(params.data[0]).format(CONFIG.dateFormat);
            const modelName = params.data[2];
            const score = params.data[1].toFixed(2);
            const color = params.seriesName === "Open" ? CONFIG.openColor : CONFIG.closedColor;
            return `<span style="color:${color}">${modelName}</span><br/>Date: ${date}<br/>Score: ${score}`;
          }
          return params.seriesName;
        },
      },
      legend: {
        data: [
          "Open",
          "Closed",
          "Open Trend",
          "Closed Trend",
          "Open Prediction",
          "Closed Prediction",
        ],
        bottom: 10,
      },
      grid: {
        left: "5%",
        right: "5%",
        bottom: "15%",
        containLabel: true,
      },
      toolbox: {
        feature: {
          saveAsImage: {},
        },
      },
      dataZoom: [
        {
          type: "inside",
          start: 0,
          end: 100,
        },
        {
          start: 0,
          end: 100,
        },
      ],
      xAxis: {
        type: "time",
        boundaryGap: false,
      },
      yAxis: {
        type: "value",
        min: "dataMin",
        max: "dataMax",
        boundaryGap: [0, "10%"],
        axisLabel: {
          formatter: "{value}%",
        },
      },
      series: [
        {
          name: "Open",
          type: "scatter",
          data: openData.map((d) => [dayjs(d.date).valueOf(), d.score, d.name]),
          symbolSize: 8,
          itemStyle: {
            color: CONFIG.openColor,
          },
        },
        {
          name: "Closed",
          type: "scatter",
          data: closedData.map((d) => [dayjs(d.date).valueOf(), d.score, d.name]),
          symbolSize: 8,
          itemStyle: {
            color: CONFIG.closedColor,
          },
        },
        {
          name: "Open Trend",
          type: "line",
          data: openTrend.trendData,
          symbolSize: 2,
          smooth: true,
          lineStyle: {
            width: 4,
            color: openTrend.color,
          },
        },
        {
          name: "Closed Trend",
          type: "line",
          data: closedTrend.trendData,
          symbolSize: 2,
          smooth: true,
          lineStyle: {
            width: 4,
            color: closedTrend.color,
          },
        },
        {
          name: "Open Prediction",
          type: "line",
          data: openTrend.predictionData,
          symbolSize: 0,
          smooth: true,
          lineStyle: {
            width: 2,
            color: openTrend.predictionColor,
            type: "dashed",
          },
        },
        {
          name: "Closed Prediction",
          type: "line",
          data: closedTrend.predictionData,
          symbolSize: 0,
          smooth: true,
          lineStyle: {
            width: 2,
            color: closedTrend.predictionColor,
            type: "dashed",
          },
        },
      ],
    };

    if (isCombined) {
      // Modify the series for the combined chart
      option.series = [
        {
          name: "Open Trend",
          type: "line",
          data: openTrend.trendData,
          symbolSize: 0,
          smooth: true,
          lineStyle: {
            width: 3,
            color: openTrend.color,
          },
        },
        {
          name: "Closed Trend",
          type: "line",
          data: closedTrend.trendData,
          symbolSize: 0,
          smooth: true,
          lineStyle: {
            width: 3,
            color: closedTrend.color,
          },
        },
        {
          name: "Open Prediction",
          type: "line",
          data: openTrend.predictionData,
          symbolSize: 0,
          lineStyle: {
            width: 2,
            color: openTrend.predictionColor,
            type: "dashed",
          },
        },
        {
          name: "Closed Prediction",
          type: "line",
          data: closedTrend.predictionData,
          symbolSize: 0,
          lineStyle: {
            width: 2,
            color: closedTrend.predictionColor,
            type: "dashed",
          },
        },
      ];

      // Add a vertical line to separate real data from predictions
      if (openTrend.trendData.length > 0) {
        const lastRealDate = openTrend.trendData[openTrend.trendData.length - 1][0];
        option.series.push({
          name: "Prediction Start",
          type: "line",
          markLine: {
            silent: true,
            lineStyle: {
              color: "#333",
            },
            data: [
              {
                xAxis: lastRealDate,
              },
            ],
            label: {
              formatter: "Prediction Start",
            },
          },
        });
      }
    }

    chart.setOption(option);
    console.log(`Chart ${id} rendered with data:`, data);

    window.addEventListener("resize", () => {
      chart.resize();
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    const charts = document.querySelectorAll(".chart");
    charts.forEach(renderChart);
  });

  document.addEventListener("DOMContentLoaded", () => {
    const tables = document.querySelectorAll(".collapsible-table");
    tables.forEach((table) => {
      const toggleBtn = table.querySelector(".toggle-table");
      const tableContainer = table.querySelector(".table-container");

      toggleBtn.addEventListener("click", () => {
        tableContainer.classList.toggle("hidden");
        toggleBtn.textContent = tableContainer.classList.contains("hidden")
          ? "Show Data"
          : "Hide Data";
      });
    });
  });
</script>
