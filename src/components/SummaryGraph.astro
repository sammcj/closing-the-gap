---
// src/components/SummaryGraph.astro
import { CONFIG } from "../config";

export interface Props {
  data: any;
  benchmarks: string[];
}

const { data, benchmarks } = Astro.props;
---

<div class="summary-graph-container">
  <select id="benchmark-selector" class="mb-4 p-2 border rounded">
    <option value="combined">Combined</option>
    {benchmarks.map((benchmark) => <option value={benchmark}>{benchmark}</option>)}
  </select>
  <div
    id="summary-graph"
    class="chart"
    style={`width: 100%; height: ${CONFIG.chartHeight * 1.3}px;`}
    data-chart-data={JSON.stringify(data)}
  >
    <p>Loading chart...</p>
  </div>
</div>

<script>
  import * as echarts from "echarts/core";
  import { ScatterChart, LineChart } from "echarts/charts";
  import {
    TitleComponent,
    TooltipComponent,
    GridComponent,
    DatasetComponent,
    TransformComponent,
    LegendComponent,
    ToolboxComponent,
    DataZoomComponent,
  } from "echarts/components";
  import { LabelLayout, UniversalTransition } from "echarts/features";
  import { CanvasRenderer } from "echarts/renderers";
  import { CONFIG } from "../config";
  import dayjs from "dayjs";

  echarts.use([
    TitleComponent,
    TooltipComponent,
    GridComponent,
    DatasetComponent,
    TransformComponent,
    LegendComponent,
    ToolboxComponent,
    DataZoomComponent,
    ScatterChart,
    LineChart,
    LabelLayout,
    UniversalTransition,
    CanvasRenderer,
  ]);

  function calculateTrendLine(data) {
    const sortedData = data.sort((a, b) => new Date(a.date) - new Date(b.date));
    const trendData = [];
    let maxScore = -Infinity;

    sortedData.forEach((point) => {
      if (point.score > maxScore) {
        maxScore = point.score;
        trendData.push([point.date, maxScore]);
      }
    });

    return trendData;
  }

  function renderSummaryGraph(element, selectedBenchmark) {
    const chartData = JSON.parse(element.getAttribute("data-chart-data"));
    const filteredData =
      selectedBenchmark === "combined"
        ? chartData
        : chartData.filter((d) => d.benchmark === selectedBenchmark);

    const openData = filteredData.filter((d) => d.openClosed === "Open");
    const closedData = filteredData.filter((d) => d.openClosed === "Closed");

    const openTrendData = calculateTrendLine(openData);
    const closedTrendData = calculateTrendLine(closedData);

    // Calculate the maximum score across all data points
    const maxScore = Math.max(...openData.map((d) => d.score), ...closedData.map((d) => d.score));

    // Set the y-axis maximum to the highest data value plus 10%
    const yAxisMax = maxScore * 1.2;

    const chart = echarts.init(element);

    const option = {
      title: {
        text: `${selectedBenchmark === "combined" ? "Combined" : selectedBenchmark} Benchmark Progress`,
        left: "center",
        top: 20,
      },
      tooltip: {
        trigger: "item",
        formatter: function (params) {
          if (params.seriesType === "scatter") {
            return `${params.seriesName}<br/>
                    Model: ${params.data.name}<br/>
                    Date: ${dayjs(params.data.date).format(CONFIG.dateFormat)}<br/>
                    Score: ${params.data.score.toFixed(2)}%`;
          } else {
            return `${params.seriesName}<br/>
                    Date: ${dayjs(params.value[0]).format(CONFIG.dateFormat)}<br/>
                    Score: ${params.value[1].toFixed(2)}%`;
          }
        },
      },
      legend: {
        data: ["Open Source", "Closed Source", "Open Source Trend", "Closed Source Trend"],
        bottom: 10,
      },
      xAxis: {
        type: "time",
        boundaryGap: false,
      },
      yAxis: {
        type: "value",
        min: 0,
        max: yAxisMax,

        axisLabel: {
          formatter: "{value}%",
        },
      },
      series: [
        {
          name: "Open Source",
          type: "scatter",
          data: openData.map((d) => ({
            value: [d.date, d.score],
            name: d.name,
            date: d.date,
            score: d.score,
          })),
          symbolSize: 8,
          itemStyle: {
            color: CONFIG.openColor,
          },
        },
        {
          name: "Closed Source",
          type: "scatter",
          data: closedData.map((d) => ({
            value: [d.date, d.score],
            name: d.name,
            date: d.date,
            score: d.score,
          })),
          symbolSize: 6,
          itemStyle: {
            color: CONFIG.closedColor,
          },
        },
        {
          name: "Open Source Trend",
          type: "line",
          data: openTrendData,
          smooth: true,
          showSymbol: true,
          lineStyle: {
            color: CONFIG.openColor,
            width: 6,
          },
          z: 10,
        },
        {
          name: "Closed Source Trend",
          type: "line",
          data: closedTrendData,
          smooth: true,
          showSymbol: true,
          lineStyle: {
            color: CONFIG.closedColor,
            width: 6,
          },
          z: 10,
        },
        {
          name: "Gap Area",
          type: "line",
          data: closedTrendData,
          smooth: true,
          showSymbol: false,
          lineStyle: {
            opacity: 0,
          },
          areaStyle: {
            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
              { offset: 0, color: echarts.color.modifyAlpha(CONFIG.closedColor, 0.3) },
              { offset: 1, color: echarts.color.modifyAlpha(CONFIG.openColor, 0.3) },
            ]),
            origin: "start",
          },
          stack: "gap",
          z: 0,
        },
        {
          name: "Gap Area Inverse",
          type: "line",
          data: openTrendData,
          smooth: true,
          showSymbol: false,
          lineStyle: {
            opacity: 0,
          },
          areaStyle: {
            color: "#fff",
            origin: "start",
          },
          stack: "gap",
          z: 5,
        },
      ],
    };

    chart.setOption(option);
  }

  document.addEventListener("DOMContentLoaded", () => {
    const summaryGraph = document.getElementById("summary-graph");
    const benchmarkSelector = document.getElementById("benchmark-selector");

    if (summaryGraph && benchmarkSelector) {
      renderSummaryGraph(summaryGraph, benchmarkSelector.value);

      benchmarkSelector.addEventListener("change", (event) => {
        renderSummaryGraph(summaryGraph, event.target.value);
      });
    }
  });
</script>
